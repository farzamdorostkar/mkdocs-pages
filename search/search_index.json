{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"LLVM_IR/","title":"LLVM IR","text":""},{"location":"LLVM_IR/#llvmstoreinst-class","title":"llvm::StoreInst Class","text":"<p>The public member function <code>Value* getPointerOperand ()</code> is a wrapper function for <code>getOperand(1)</code>.</p> llvm/include/llvm/IR/Instructions.h<pre><code>Value *getPointerOperand() { return getOperand(1); }\n</code></pre> <p>The first class types are perhaps the most important. Values of these types are the only ones which can be produced by instructions.</p>"},{"location":"LLVM_IR/#static-value-flow-analysis-framework-svf","title":"Static Value-Flow Analysis Framework (SVF)","text":""},{"location":"LLVM_IR/#build","title":"Build","text":"<p>Note: SVF uses CMake to generate build files for compiling the project. Starting with SVF version 2.9, the framework leverages the <code>FILE_SET</code> feature introduced in CMake version 3.23, which allows grouping related files within a target. Therefore, to successfully generate build files for SVF version 3, you must use CMake version 3.23 or higher.</p>"},{"location":"assembly/","title":"System V AMD64 ABI","text":""},{"location":"assembly/#stack-frame","title":"Stack Frame","text":"<p>A calling convention specifies how functions receive parameters, return values, and how the call stack and registers are managed.</p> <p>The stack pointer <code>%rsp</code> points to the top element of the stack.</p> <p>Data can be stored on and retrieved from the stack using the <code>push</code> and <code>pop</code> instructions. Space for data with no specified initial value can be allocated on the stack by simply decrementing the stack pointer by an appropriate amount. Similarly, space can be deallocated by incrementing the stack pointer.</p>"},{"location":"assembly/#caller-saved-vs-callee-saved-registers","title":"Caller-saved vs Callee-saved Registers","text":"<p>The calling convention provides callers and callees with specific guarantees and responsibilities regarding register values across function calls. Certain registers must have their values preserved across function calls. A callee may use these registers, but if it wants to modify them, it must save their original values and restore them before returning. These are known as callee-saved registers. All other registers are known as caller-saved registers, meaning that if a caller needs to preserve their values across a function call, it must explicitly save them before the call and restore them after the callee returns.</p> <p>Registers <code>%rbp</code>, <code>%rbx</code> and <code>%r12</code> through <code>%r15</code> \u201cbelong\u201d to the calling function and the called function is required to preserve their values. In other words, a called function must preserve these registers\u2019 values for its caller. Remaining registers \u201cbelong\u201d to the called function. If a calling function wants to preserve such a register value across a function call, it must save the value in its local stack frame. <sup>1</sup></p> <p>As an example, consider the C code below, where the callee writes to <code>%rbx</code> which is a callee-saved register.</p> callee_saved_example.c<pre><code>void __attribute__((noinline)) foo() {\n  __asm__ volatile (\"movq $0xDEADBEEFDEADBEEF, %%rbx\\n\\t\":::\"rbx\");\n}\n\nint main() {\n  foo();\n  return 0;\n}\n</code></pre> <p>Below is the generated assembly for the callee function. </p> callee_saved_example.s<pre><code>foo:\n  pushq %rbp\n  movq  %rsp, %rbp\n  pushq %rbx\n  movq $0xDEADBEEFDEADBEEF, %rbx\n  movq  -8(%rbp), %rbx\n</code></pre> <ol> <li> <p>System V Application Binary Interface. AMD64 Architecture Processor Supplement, Draft v0.99.6\u00a0\u21a9</p> </li> </ol>"},{"location":"memory/","title":"Memory","text":"<p>Everything About Memory!</p>"},{"location":"memory/#1-virtual-memory","title":"1. VIRTUAL MEMORY","text":"<p>\"The lowest twelve bits of the virtual address are the offset into the page itself.\" [https://lwn.net/Articles/717293/]     * page size = 2^12 = 4096 (~4k)</p> <p>PAGE TABLES</p> <p>*Address Translation with a Page Table     Every process has its own page table.     Page Table Base Register (PTBR): pointer to the begining of the page table for a specific process     Modern page tables are arranged as arrays, where every entry is of fixed size. i-th entry in the page table is the i-th virtual page of the memory layout of that process.     Valid/Present bit: whether or not this mapping is true (page table hit/miss)     If physical and virtual pages are of the same size, which is the way that makes the most sense, nothing special has to happen to translate VPO to PPO.     Page fault happens in order to bring things into RAM.</p> <pre><code>             ---------------------------------------------------------\n</code></pre> <p>Virtual address: | Virtual Page Number (VPN) | Virtual Page Offset (VPO) |                  ---------------------------------------------------------                     |                                                   |                     |   ------------------------------------------      | Page table:         --&gt; | valid bit | Physical Page Number (PPN) |      |                         ------------------------------------------      |                                         |                               |                                         | valid bit = 1                 |                                         V                               V                      ----------------------------------------------------------- Physical address:   | Physical Page Number (PPN) | Physical Page Offset (PPO) |                     -----------------------------------------------------------</p> <pre><code>                                -----------------------------------------------------------\n</code></pre> <p>*Extend PTEs with perission bits:   | VALID/PRES | WRITE | USER | EXEC | Physical Page Number |                                     -----------------------------------------------------------     WRITE:  1 if wrting to that page is allowed     USER:   1 if we are allowed to access it in user mode, 0 if kernel-moode only.     EXEC:   1 if executable code is allowed in that page of memory (security defense).     MMU checks these bits on each access.     Virtual page number is the offset.</p> <p>*Types of memory in use by a process:     user-level text:    WRITE = 0 (a security vulnerability or too complicated self-modifying code), USER = 1, EXEC = 1     user-level stack:   WRITE = 1, USER = 1, EXEC = 0 (we don't load code into the stack)     user-level heap:    WRITE = 1, USER = 1, EXEC = 0 (we don't load code into the heap, eventhough they are in the same basic area of memory)     kernel text:        WRITE = 0, USER = 0, EXEC = 1     kernel stack:       WRITE = 1, USER = 0, EXEC = 0     kernel stack:       WRITE = 1, USER = 0, EXEC = 0</p> <p>*Speeding up Translation with a Translation Lookaside Buffer (TLB)     small set-associative hardware cache in MMU - PTE cache on MMU     mapps virtual page numbers to physical page numbers     contains complete page table entries for small number of pages     TLB uses the virtual page number as an index into a set-associative cache to keep track of page table entries.     A TLB hit eliminates a memory access. In this case, the only time CPU touches main memory (through cache hierarchy) is doing the load/store from/to the physical address.     A TLB miss incures an additional memory access (the PTE).     If TLB miss: MMU asks main memory for the page table entry that lives at a specific physical address (we know the base register and we know which virtual page number we need).</p> <p>*Accessing the TLB     MMU uses the VPN portion of the virtual address to access the TLB</p> <pre><code>                &lt;-------------- VPN ---------------&gt;\n                n-1           p+t p+t-1            p p-1  0\n                -------------------------------------------\n</code></pre> <p>virtual address:    | TLB tag (TLBT) | TLB index (TLBI) | VPO |                     -------------------------------------------                                 |                   |                                 ---------           |     TLBT matches tag of line within set |           | TLBI selects the set                                         |           | Set 0                                   |           |                                         V           |         -----------------       -----------------   | set 1   | v | tag | PTE |  ...  | v | tag | PTE |&lt;---         -----------------       ----------------- ...</p> <p>set T-1 (T = 2^t sets)</p> <p>*Sizing the page table:     All modern computers use byte-addressable memory.     An N-bit architecture does not mean we need to have N-bit physical address size.     Width of every PTE = meta data + PPN</p> <pre><code>                                                -------------------------------------\n</code></pre> <p>Logical address (address of an individual byte):    | Page p | Offset i (within a page) |                                                     -------------------------------------                                                         |                           |                                                         V                           |     Number of bits n specifies max size of table, where number of entries = 2^n     V                                                                                 Number of bits n specifies page size (for example 12 bits for 4096-byte pages) *Modern X86_64 processors     48 bit logical (virtual) address: 36 bit page number + 12 bit offset (~4KB pages)     52 bit physical address --&gt; 52 - 12 = 40 bit physical frame number     PTE size: 40 bits (frame) + meta data = 64 bits     2^36 entries     page table size = 512 GB?! --&gt; solution: Multi Level Page Table (MLPT)</p> <p>*Translating with a k-level page table     For the first-level (highest-level) page table, the base address is stored in the page table base address. VPN1 is the offset.     Each entry in the first-level page table is a physical address that is the base of a second-level page table. VPN2 is the offset of this page table. And so on...     Some page table entries might be null, in which case there is no entry array for that region of memory.     On the last level, we find a physical page number (PPN) that does not refer to another page table (i.e. it is not the base of a page table), but it is the actual physical page number.</p> <ul> <li>Linux Multi-Level Page Tables<pre><code>        -----------------------------------------------------------------------------------------------------\n        |       VPN1        |       VPN2        |       VPN3        |       VPN4        |       VPO         |\n        -----------------------------------------------------------------------------------------------------\n                    |\n                    |\n                    |\n                    |       ---------\n</code></pre> <p>CR3 ------------ /40/ -----------&gt;  |       | Physical address of L1 PT   |       |       |                          |       |-------|                         - /9/ -&gt;|L1 PTE |                                 |-------|                                 ---------</p> </li> </ul>"},{"location":"shell/","title":"Linux Shell","text":""},{"location":"shell/#shell-vs-environment-variables","title":"Shell vs Environment variables","text":"<p>Shell variables are only present in the shell in which they were defined. They are not automatically available to the programs or scripts that are started by the shell. To create or modify a shell variable, you simply assign a value to a name without spaces:</p> <pre><code>VARIABLE_NAME=value\n</code></pre> <p>Here, <code>VARIABLE_NAME</code> is a shell variable. Notably, this variable will not be recognized in any programs or scripts launched from the current shell session.</p> <p>Environment variables are a special type of shell variable that are inherited by any child processes started from the shell. Environment variables are set using the <code>export</code> command.</p>"},{"location":"shell/#export","title":"export","text":"<p>This command is a built-in utility of Linux Bash shell, used to set environment variables for the current shell session and its child processes. When you run <code>export VARIABLE_NAME=value</code> you are creating or modifying an environment variable in your current shell session and ensuring that any processes started from this session inherit this environment variable.</p> <p>For example, if you run</p> <pre><code>export PATH=/new/directory:$PATH\n</code></pre> <p>you are modifying the <code>PATH</code> environment variable to include a new directory. Any program or script you run from this shell session will have access to this updated <code>PATH</code> variable. This is crucial for configuring the runtime environment of software, managing paths, and setting up variables that programs depend on.</p> <p>To print a list of all exported environment variables in the current shell session run</p> <pre><code>export -p\n</code></pre> <p>where the <code>-p</code> option stands for \"print\".</p>"}]}